<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini SIEM Dashboard</title>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Leaflet CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 2em; background: #f7f7f7; }
        h1 { color: #333; }
        .stats { margin-bottom: 2em; }
        .analytics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2em;
            margin-bottom: 2em;
        }
        .card {
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            padding: 0.5em 0.7em 0.3em 0.7em;
            min-height: 170px;
            max-height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }
        .card > h2 {
            margin-bottom: 0.5em;
        }
        .card > #geoMap,
        .card > canvas {
            flex-grow: 1;
            height: 100% !important;
            min-height: 0;
            max-height: none;
        }
        .card h2 {
            font-size: 1.1em;
            margin-bottom: 0.7em;
        }
        #geoMap,
        #eventsOverTimeChart,
        #topIPsChart {
            width: 100% !important;
            height: 100% !important;
            min-height: 0;
            max-height: none;
            flex-grow: 1;
        }
        #protocolChart {
            display: block;
            margin: auto;
            width: 70% !important;
            height: 90% !important;
            aspect-ratio: 1 / 1;
            min-width: 100px;
            min-height: 100px;
            max-width: 70%;
            max-height: 100%;
        }
        @media (max-width: 900px) {
            .analytics-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
        }
        .card {
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            padding: 1em;
            min-height: 340px;
            display: flex;
            flex-direction: column;
        }
        .card h2 {
            font-size: 1.1em;
            margin-bottom: 0.7em;
        }
        table { border-collapse: collapse; width: 100%; margin-bottom: 1em; font-size: 0.95em; }
        th, td { border: 1px solid #ccc; padding: 0.4em 0.6em; text-align: left; }
        th { background: #eee; position: sticky; top: 0; z-index: 2; }
        .recent-events {
            max-height: 350px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        #recentEvents tbody tr:nth-child(even) { background: #f2f2f2; }
        #recentEvents tbody tr:hover { background: #dbeafe; }
        #recentEvents td { font-family: 'Fira Mono', 'Consolas', 'Menlo', monospace; font-size: 0.97em; }
        .compact-table th, .compact-table td { padding: 0.3em 0.5em; }
    </style>
</head>
<body>
    <h1>Mini SIEM Dashboard</h1>
    <div class="stats" style="display: flex; gap: 2em; align-items: center; margin-bottom: 2em;">
        <div style="flex: 1; font-size: 1.1em;">
            <strong>Total Events:</strong> <span id="totalEvents">0</span>
        </div>
        <div style="flex: 1; font-size: 1.1em;">
            <strong>Last 24 Hours:</strong> <span id="last24h">0</span>
        </div>
    </div>
    <section class="analytics-grid">
        <div class="card">
            <h2>Geo-IP Map</h2>
            <div id="geoMap" style="height: 300px; width: 100%;"></div>
        </div>
        <div class="card">
            <h2>Events Over Time</h2>
            <canvas id="eventsOverTimeChart"></canvas>
        </div>
        <div class="card">
            <h2>Top IPs</h2>
            <canvas id="topIPsChart"></canvas>
        </div>
        <div class="card">
            <h2>Events by Protocol</h2>
            <canvas id="protocolChart"></canvas>
        </div>
    </section>

    <div style="display: flex; gap: 2em; align-items: flex-start; margin-bottom: 2em;">
        <div style="flex: 1;">
            <h2>Top IPs (Table)</h2>
            <table id="topIPs">
                <thead><tr><th>IP</th><th>Count</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        <div style="flex: 1;">
            <h2>Top Ports</h2>
            <table id="topPorts">
                <thead><tr><th>Port</th><th>Count</th></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    <h2>Recent Events</h2>
    <div class="recent-events">
    <table id="recentEvents" class="compact-table">
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>IP</th>
                    <th>Port</th>
                    <th>Src Port</th>
                    <th>Protocol</th>
                    <th>Type</th>
                    <th>Message</th>
                    <th>User Agent</th>
                    <th>Banner Sent</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <script>
        // Chart.js chart objects
        let eventsOverTimeChart, topIPsChart, protocolChart;
        let geoMap, geoMarkers = [];

        function groupEventsByMinute(events) {
            // Group events by minute (UTC)
            const buckets = {};
            events.forEach(ev => {
                if (!ev.timestamp) return;
                const d = new Date(ev.timestamp);
                const key = d.getUTCFullYear() + '-' + (d.getUTCMonth()+1).toString().padStart(2,'0') + '-' + d.getUTCDate().toString().padStart(2,'0') + ' ' + d.getUTCHours().toString().padStart(2,'0') + ':' + d.getUTCMinutes().toString().padStart(2,'0');
                buckets[key] = (buckets[key] || 0) + 1;
            });
            const labels = Object.keys(buckets).sort();
            const data = labels.map(l => buckets[l]);
            return { labels, data };
        }

        function groupEventsByProtocol(events) {
            const counts = {};
            events.forEach(ev => {
                const proto = ev.protocol || "Unknown";
                counts[proto] = (counts[proto] || 0) + 1;
            });
            const labels = Object.keys(counts);
            const data = labels.map(l => counts[l]);
            return { labels, data };
        }

        // Simple in-memory cache for IP geolocation
        const ipGeoCache = {};

        async function fetchGeo(ip) {
            if (ipGeoCache[ip]) return ipGeoCache[ip];
            try {
                const resp = await fetch(`https://ip-api.com/json/${ip}?fields=status,country,lat,lon`);
                const data = await resp.json();
                if (data.status === "success") {
                    ipGeoCache[ip] = {
                        country: data.country,
                        latitude: data.lat,
                        longitude: data.lon
                    };
                    return ipGeoCache[ip];
                }
            } catch {}
            ipGeoCache[ip] = null;
            return null;
        }

        async function buildGeoMarkers(events) {
            // Add markers for events with geo data, or fetch it if missing
            const markers = [];
            const ipCounts = {};
            for (const ev of events) {
                ipCounts[ev.ip] = (ipCounts[ev.ip] || 0) + 1;
            }
            // Only unique IPs
            const uniqueIPs = [...new Set(events.map(ev => ev.ip))];
            // Fetch geo data for all unique IPs
            const geoResults = {};
            await Promise.all(uniqueIPs.map(async ip => {
                geoResults[ip] = await fetchGeo(ip);
            }));
            for (const ev of events) {
                const geo = geoResults[ev.ip];
                if (geo && typeof geo.latitude === "number" && typeof geo.longitude === "number") {
                    const popup = `<strong>IP:</strong> ${ev.ip}<br>` +
                        (geo.country ? `<strong>Country:</strong> ${geo.country}<br>` : "") +
                        `<strong>Protocol:</strong> ${ev.protocol}<br>` +
                        `<strong>Events:</strong> ${ipCounts[ev.ip]}`;
                    markers.push({
                        lat: geo.latitude,
                        lng: geo.longitude,
                        popup
                    });
                }
            }
            return markers;
        }

        function updateEventsOverTimeChart(events) {
            const { labels, data } = groupEventsByMinute(events);
            if (!eventsOverTimeChart) {
                const ctx = document.getElementById('eventsOverTimeChart').getContext('2d');
                eventsOverTimeChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Events',
                            data,
                            borderColor: '#2563eb',
                            backgroundColor: 'rgba(37,99,235,0.1)',
                            fill: true,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: { x: { title: { display: true, text: 'Time (UTC)' } }, y: { title: { display: true, text: 'Events' }, beginAtZero: true } }
                    }
                });
            } else {
                eventsOverTimeChart.data.labels = labels;
                eventsOverTimeChart.data.datasets[0].data = data;
                eventsOverTimeChart.update();
            }
            if (labels.length === 0) {
                document.getElementById('eventsOverTimeChart').parentElement.innerHTML = '<div style="padding:2em;text-align:center;color:#888;">No data yet</div>';
            }
        }

        function updateTopIPsChart(topIPs) {
            const labels = topIPs.slice(0,10).map(ip => ip.ip);
            const data = topIPs.slice(0,10).map(ip => ip.count);
            if (!topIPsChart) {
                const ctx = document.getElementById('topIPsChart').getContext('2d');
                topIPsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Events',
                            data,
                            backgroundColor: '#22d3ee'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: { x: { title: { display: true, text: 'Events' }, beginAtZero: true }, y: { title: { display: true, text: 'IP' } } }
                    }
                });
            } else {
                topIPsChart.data.labels = labels;
                topIPsChart.data.datasets[0].data = data;
                topIPsChart.update();
            }
            if (labels.length === 0) {
                document.getElementById('topIPsChart').parentElement.innerHTML = '<div style="padding:2em;text-align:center;color:#888;">No data yet</div>';
            }
        }

        function updateProtocolChart(events) {
            const { labels, data } = groupEventsByProtocol(events);
            if (!protocolChart) {
                const ctx = document.getElementById('protocolChart').getContext('2d');
                protocolChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Events',
                            data,
                            backgroundColor: ['#2563eb','#22d3ee','#f59e42','#f43f5e','#10b981','#a78bfa','#fbbf24','#eab308']
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { position: 'bottom' } }
                    }
                });
            } else {
                protocolChart.data.labels = labels;
                protocolChart.data.datasets[0].data = data;
                protocolChart.update();
            }
            if (labels.length === 0) {
                document.getElementById('protocolChart').parentElement.innerHTML = '<div style="padding:2em;text-align:center;color:#888;">No data yet</div>';
            }
        }

        async function updateGeoMap(events) {
            if (!geoMap) {
                geoMap = L.map('geoMap').setView([20, 0], 2);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                    attribution: 'Â© OpenStreetMap'
                }).addTo(geoMap);
            }
            // Remove old markers
            geoMarkers.forEach(m => geoMap.removeLayer(m));
            geoMarkers = [];
            const markers = await buildGeoMarkers(events);
            if (markers.length === 0) {
                document.getElementById('geoMap').innerHTML = '<div style="padding:2em;text-align:center;color:#888;">No geo data available yet</div>';
                return;
            } else {
                document.getElementById('geoMap').innerHTML = '';
            }
            markers.forEach(m => {
                const marker = L.marker([m.lat, m.lng]).addTo(geoMap);
                marker.bindPopup(m.popup);
                geoMarkers.push(marker);
            });
        }

        async function fetchStats() {
            fetch('/api/stats').then(r => r.json()).then(async data => {
                document.getElementById('totalEvents').textContent = data.totalEvents;
                document.getElementById('last24h').textContent = data.last24h;
                // Top IPs Table
                let ipRows = '';
                data.topIPs.forEach(ip => {
                    ipRows += `<tr><td>${ip.ip}</td><td>${ip.count}</td></tr>`;
                });
                document.querySelector('#topIPs tbody').innerHTML = ipRows;
                // Top Ports Table
                let portRows = '';
                data.topPorts.forEach(port => {
                    portRows += `<tr><td>${port.port}</td><td>${port.count}</td></tr>`;
                });
                document.querySelector('#topPorts tbody').innerHTML = portRows;
                // Recent Events Table
                let eventRows = '';
                data.recentEvents.forEach(ev => {
                    eventRows += `<tr>
                        <td>${ev.timestamp}</td>
                        <td>${ev.ip}</td>
                        <td>${ev.port}</td>
                        <td>${ev.src_port ?? ""}</td>
                        <td>${ev.protocol}</td>
                        <td>${ev.event_type}</td>
                        <td>${ev.message}</td>
                        <td>${ev.user_agent ?? ""}</td>
                        <td>${typeof ev.banner_sent === "boolean" ? String(ev.banner_sent) : ""}</td>
                    </tr>`;
                });
                document.querySelector('#recentEvents tbody').innerHTML = eventRows;

                // Update analytics visuals
                updateEventsOverTimeChart(data.recentEvents);
                updateTopIPsChart(data.topIPs);
                updateProtocolChart(data.recentEvents);
                await updateGeoMap(data.recentEvents);
            });
        }
        fetchStats();
        setInterval(fetchStats, 5000);
    </script>
</body>
</html>
